[toc]

# 创建型模式

>关注对象的创建过程

## 单例模式

```java
// 懒加载 √
// 线程安全 X
public class Singleton {
    private Singleton() {} // 构造器私有

    /**
     * 初始化对象为null
     */
    private static Singleton instance = null;

    public static Singleton getInstance() {
        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

```java
// 懒加载 X
// 线程安全√
// 在编译器直接构建
public class Singleton {
    private Singleton() {} // 构造器私有

    private static Singleton instance = new Singleton();

    public static Singleton getInstance() {
        return instance;
    }
}
```

```java
// 线程安全√
// 懒加载 √
// 双检锁
public class Singleton {
    // volatile 防止指令重排，可以防止其他线程在getInstance()上面一个if判断时，false，直接return，而此时singleton还是null
    private volatile static Singleton singleton;

    private Singleton(){};

    public static Singleton getInstance() {
        // 双检锁
        if(singleton == null) {
            synchronized (Singleton.class) {
                if(singleton == null) {
                    // 不加里面的判空会出现在没有锁住时，已经有线程进入了上面的一个if，从而多次创建对象
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

## 工厂模式

实现创建者和调用者的分离

#### 简单工厂模式

​	用来生产同一等级结构中的任意产品（对于增加新的产品需要修改已有的代码，不遵守开放封闭原则）

```java
// Car1,Car2实现了Car
// 比如有两个汽车类都实现了汽车接口
// 不使用简单工厂模式
Car car1 = new Car1();
Car car2 = new Car2();
// 使用简单工厂模式，不关心创建过程，需要谁就给工厂参数，让工厂去创建
Car car1 = CarFactory.createCar("car1");
Car car2 = CarFactory.createCar("car2");

public class CarFactory {
    public static Car createCar(String type) {
        Car c = null;
        if("car1".equals(type)) {
            c = new Car1();
        } else if("car2".equals(type)) {
            c = new Car2();
        } 
        return c;
    }
}

// 第二种简单工厂模式
// 遵循开闭原则
Car car1 = CarFactory.CreateCar1();
Car car2 = CarFactory.CreateCar2();

public class CarFactory {
    public static Car CreateCar1() {
        return new Car1();
    }
    public static Car CreateCar2() {
        return new Car2();
    }
}
```



#### 工厂方法模式

​	为了避免简单工厂不完全满足开闭原则

​	工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个工厂类，而工厂方法模式有一组实现了相同接口的工厂类

```java
/**
 * @author uio
 * 工厂方法模式
 * 为了避免简单不完全满足开闭原则
 * 工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个工厂类，而工厂方法模式有一组实现了相同接口的工厂类
 */
public class FactoryMethod {

    Car car1 = new Car3().createCar();
    Car car2 = new Car4().createCar();

}

interface CarFactoryForFactoryMethod {
    Car createCar();
}


class Car3 implements CarFactoryForFactoryMethod, Car {
    @Override
    public Car createCar() {
        return new Car3();
    }
}

class Car4 implements CarFactoryForFactoryMethod, Car {
    @Override
    public Car createCar() {
        return new Car4();
    }
}
```



#### 抽象工厂模式

​	用来生产**不同产品族**的全部产品（对于新增加的产品无能为力，支持新增产品族）

```java
package abstractFactory;

public interface CarFactory {
    Engine createEngine();
    Seat createSeat();
    Tyre createTyre();
}

class LuxuryCarFactory implements CarFactory {

    @Override
    public Engine createEngine() {
        return new LuxuryEngine();
    }

    @Override
    public Seat createSeat() {
        return new LuxurySeat();
    }

    @Override
    public Tyre createTyre() {
        return new LuxuryTyre();
    }
}

class LowCarFactory implements CarFactory {

    @Override
    public Engine createEngine() {
        return new LowEngine();
    }

    @Override
    public Seat createSeat() {
        return new LowSeat();
    }

    @Override
    public Tyre createTyre() {
        return new LowTyre();
    }
}
```

```java
package abstractFactory;

public interface Engine {
    void run();
    void start();
}

class LuxuryEngine implements Engine{

    @Override
    public void run() {
        // doSomethings
    }

    @Override
    public void start() {
        // doSomethings
    }
}

class LowEngine implements Engine {

    @Override
    public void run() {
        // doSomethings
    }

    @Override
    public void start() {
        // doSomethings
    }
}
```

```java
package abstractFactory;

public interface Seat {
    void message();
}

class LuxurySeat implements Seat {

    @Override
    public void message() {
        // doSomethings
    }
}

class LowSeat implements Seat {

    @Override
    public void message() {
        // doSomethings
    }
}
```

```java
package abstractFactory;

public interface Tyre {
    void revolve();
}

class LuxuryTyre implements Tyre {

    @Override
    public void revolve() {
        // doSomethings
    }
}

class LowTyre implements Tyre {

    @Override
    public void revolve() {
        // doSomethings
    }
}
```

## 建造者模式

#### 创建型模式

​	当需要创建一个复杂的产品时，比如：神舟飞船，手机。

​	实现了组件的单独构造（Builder负责）和装配（Director负责）

​	实际开发过程中，会与工厂模式搭建。

客户端（调用）

```java
package builder;

public class Client {
    public static void main(String[] args) {
        AirShipDirector director = new OneAirShipDirector(new OneAirShipBuilder());
        AirShip airShip = director.createAriShip();
    }
}
```

对象

```java
package builder;

/**
 * @author uio
 */
public class AirShip {

    private OribitalModule orbitalModule;
    private Engine engine;
    private EscapeTower escaoeTower;

    public OribitalModule getOrbitalModule() {
        return orbitalModule;
    }

    public void setOrbitalModule(OribitalModule orbitalModule) {
        this.orbitalModule = orbitalModule;
    }

    public Engine getEngine() {
        return engine;
    }

    public void setEngine(Engine engine) {
        this.engine = engine;
    }

    public EscapeTower getEscaoeTower() {
        return escaoeTower;
    }

    public void setEscaoeTower(EscapeTower escaoeTower) {
        this.escaoeTower = escaoeTower;
    }
}

class OribitalModule {
    private String name;

    public OribitalModule(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

class Engine {
    private String name;

    public Engine(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

class EscapeTower {
    private String name;

    public EscapeTower(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

建造者

```
package builder;

/**
 * 建造
 * @author uio
 */
public interface AirShipBuilder {
    Engine builderEngine();
    OribitalModule builderOrbitalModule();
    EscapeTower builderEscapeTower();
}
```

```java
package builder;

/**
 * @author uio
 * 一个构建者
 */
public class OneAirShipBuilder implements AirShipBuilder{

    /**
     * 构建发动机等产品时，可以与工厂模式结合
     */
    @Override
    public Engine builderEngine() {
        System.out.println("构建发动机");
        return new Engine("One构建的发动机");
    }

    @Override
    public OribitalModule builderOrbitalModule() {
        return new OribitalModule("One构建的轨道舱");
    }

    @Override
    public EscapeTower builderEscapeTower() {
        return new EscapeTower("One构建的逃逸塔");
    }
}
```

装配

```java
package builder;

/**
 * 装配
 * @author uio
 */
public interface AirShipDirector {
    AirShip createAriShip();
}
```

```java
package builder;

public class OneAirShipDirector implements AirShipDirector {

    private AirShipBuilder airShipBuilder;

    public OneAirShipDirector(AirShipBuilder airShipBuilder) {
        this.airShipBuilder = airShipBuilder;
    }

    /**
     * 装配成需要的对象
     * @return
     */
    @Override
    public AirShip createAriShip() {
        Engine e = airShipBuilder.builderEngine();
        OribitalModule o = airShipBuilder.builderOrbitalModule();
        EscapeTower es = airShipBuilder.builderEscapeTower();

        AirShip airShip = new AirShip();
        airShip.setEngine(e);
        airShip.setEscaoeTower(es);
        airShip.setOrbitalModule(o);
        return null;
    }
}
```

## 原型模式

- 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式
- 就是java的克隆技术，以某个对象为原型，复制出新的对象，显然新的对象具备原型对象的特点
- 优势：效率高（直接克隆，避免了重复执行构造过程步骤）
- 实现：类中实现Cloneable接口和clone方法
- 利用Java提供的clone()方法

#### 浅克隆

```java
package prototype;

import java.util.Date;

public class Sheep implements Cloneable {
    private String name;
    private Date birthday;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        Object obj = super.clone(); // 直接调用object对象的clone()方法
        return obj;
    }

    public Sheep(String name, Date birthday) {
        this.name = name;
        this.birthday = birthday;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }
}
```

```java
package prototype;

import java.util.Date;

/**
 * 原型模式 浅克隆
 * 测试原型模式
 */
public class Client {
    public static void main(String[] args) throws CloneNotSupportedException {
        Date date = new Date(111111111L);

        Sheep sheep = new Sheep("sheep1", date);
        System.out.println(sheep);
        Sheep s2 = (Sheep) sheep.clone();
        System.out.println(s2);
        // 地址与sheep不同

        date.setTime(222222222L);
        System.out.println(sheep.getBirthday());
        System.out.println(s2.getBirthday());
        // 两者的birthday属性都变了，因为是浅克隆，只克隆了引用的地址，没有克隆引用的对象（两者引用了同一个对象date)

        /*
        prototype.Sheep@61bbe9ba
        prototype.Sheep@610455d6
        Sat Jan 03 21:43:42 CST 1970
        Sat Jan 03 21:43:42 CST 1970
         */
    }
}

```

#### 深拷贝

```java
package prototype;

import java.util.Date;

public class Sheep2 implements Cloneable{
    private String name;
    private Date birthday;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        Object obj = super.clone();
        Sheep2 sheep2 = (Sheep2) obj;
        sheep2.birthday = (Date) this.birthday.clone();
        return obj;
    }

    public Sheep2(String name, Date birthday) {
        this.name = name;
        this.birthday = birthday;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }
}
```

```java
package prototype;

import java.util.Date;

/**
 * 原型模式 深复制
 */
public class Client2 {

    public static void main(String[] args) throws CloneNotSupportedException {
        Date date = new Date(111111111L);

        Sheep2 sheep = new Sheep2("sheep1", date);
        System.out.println(sheep);
        Sheep2 s2 = (Sheep2) sheep.clone();
        System.out.println(s2);
        // 地址与sheep不同

        date.setTime(222222222L);
        System.out.println(sheep.getBirthday());
        System.out.println(s2.getBirthday());

        /*
        prototype.Sheep2@61bbe9ba
        prototype.Sheep2@610455d6
        Sat Jan 03 21:43:42 CST 1970
        Fri Jan 02 14:51:51 CST 1970
         */
    }
}
```

# 结构型模式

> 从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题
>
> 关注对象和类的组织关系

## 适配器模式

Adapter pattern

将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于借口不兼容而不能一起工作的类可以一起工作

Target目标接口，客户所期待的借口。目标可以是具体的或抽象的类，也可以是接口。

Adaptee适配的类，需要适配的类或适配者类

Adapter适配器，通过包装一个需要适配的对象，把原接口转化成目标接口

```java
package adapter;

/**
 * 客户类
 */
public class Client {

    public void test(Target t) {
        t.handleRequest();
    }

    public static void main(String[] args) {
        Client c = new Client();
        Adaptee a = new Adaptee();
        
        Target t1 = new Adapter();
        t1.handleRequest();
        
        Target t2 = new Adapter2(a);
        t2.handleRequest();
        
        c.test(t1);
        c.test(t2);
    }
}
```

```java
package adapter;

/**
 * 被适配的类
 */
public class Adaptee {

    public void request() {
        System.out.println("out");
    }
}
```

```java
package adapter;

public interface Target {

    void handleRequest();
}
```

```java
package adapter;

/**
 * 适配器（类适配器，用继承的方式实现）
 */
public class Adapter extends Adaptee implements Target{

    @Override
    public void handleRequest() {
        super.request();
    }
}
```

```java
package adapter;

/**
 * 适配器（对象适配器方式，组合）
 */
public class Adapter2 implements Target{

    private Adaptee adaptee;

    public Adapter2(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public void handleRequest() {
        adaptee.request();
    }
}
```

## 代理模式

Proxy pattern

- 核心角色：
  - 抽象角色：定义代理角色和真实角色的公共对外方式
  - 真实角色：实现抽象角色，定义真正角色所实现的业务逻辑，供代理角色调用。关注真正的业务逻辑
  - 代理角色：代理抽象角色，是真正角色的代理，通过真实角色的业务逻辑来实现抽象角色，并可以附加自己的操作。**将统一的流程控制放到代理角色中处理**

- 应用场景：
  - 安全代理：屏蔽掉真实角色的直接访问
  - 远程代理：通过代理类处理远程方法调用（RMI）
  - 延迟加载：先夹在轻量级的代理对象，真正需要在加载真是对象
- 分类：
  - 静态代理（静态定义代理类）
  - 动态代理（动态生成代理类）
    - JDK自带的动态代理
    - javaassist字节码操作库实现
    - CGLIB
    - ASM（底层使用指令，可维护性较差）

#### 静态代理

static proxy

```java
package proxy.staticProxy;

public class Client {

    public static void main(String[] args) {
        Star real = new RealStar();
        Star proxy = new ProxyStar(real);

        proxy.confer();
        proxy.signContract();

        proxy.sing(); // 内部调用了真实的类。在客户端调用代理类的sing方法
    }
}
```

```java
package proxy.staticProxy;

/**
 * 代理明星
 */
public class ProxyStar implements Star {

    private Star star;

    public ProxyStar(Star star) {
        super();
        this.star = star;
    }

    @Override
    public void confer() {
        System.out.println("ProxyStar.confer()");
    }

    @Override
    public void signContract() {
        System.out.println("ProxyStar.sign");
    }

    /**
     * 调用真实对象的sing方法
     */
    @Override
    public void sing() {
        star.sing();
    }
}
```

```java
package proxy.staticProxy;

/**
 * 真实的明星类
 */
public class RealStar implements Star{

    @Override
    public void confer() {
        System.out.println("RealStar.Confer()");
    }

    @Override
    public void signContract() {
        System.out.println("RealStar.sign()");
    }

    @Override
    public void sing() {
        System.out.println("RealStar.sing()");
    }
}
```

```java
package proxy.staticProxy;

/**
 * 接口
 */
public interface Star {
    /**
     * 面谈
     */
    void confer();

    /**
     * 签合同
     */
    void signContract();

    /**
     * 唱歌
     */
    void sing();
}
```

#### 动态代理

Dynamic Proxy

```java
package proxy.dynamicProxy;

import java.lang.reflect.Proxy;

public class Client {
    public static void main(String[] args) {
        Star realStar = new RealStar();
        StarHandler handler = new StarHandler(realStar);

        Star proxy = (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Star.class}, handler);

        proxy.confer();
        proxy.signContract();
        proxy.sing();
    }
}
```

```java
package proxy.dynamicProxy;

/**
 * 真实的明星类
 */
public class RealStar implements Star {

    @Override
    public void confer() {
        System.out.println("RealStar.Confer()");
    }

    @Override
    public void signContract() {
        System.out.println("RealStar.sign()");
    }

    @Override
    public void sing() {
        System.out.println("RealStar.sing()");
    }
}
```

```java
package proxy.dynamicProxy;

/**
 * 接口
 */
public interface Star {
    /**
     * 面谈
     */
    void confer();

    /**
     * 签合同
     */
    void signContract();

    /**
     * 唱歌
     */
    void sing();
}
```

```java
package proxy.dynamicProxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class StarHandler implements InvocationHandler {

    Star realStar;

    public StarHandler(Star realStar) {
        this.realStar = realStar;
    }

    /*
    核心方法
    */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        System.out.println("进入代理类");

        if(method.getName().endsWith("sing")) {
            // 进入核心类
            method.invoke(realStar, args);
        }
        return null;
    }
}
```

## 桥接模式

Bridge pattern

- 场景：商城系统中常见的商品分类，以电脑为类，如何良好的处理商品分类销售的问题
- 处理两种以上纬度的信息。比如电脑有品牌以及功能（品牌1/品牌2 + 桌面电脑/移动笔记本电脑/平板电脑） 
- 场景：
  - JDBC驱动程序
  - 银行日志管理（两个维度）：
    - 格式分类：操作日志、交易日志、异常日志
    - 距离分类：粉底记录日志、异地记录日志

```java
package bridge;

public interface Brand {
    void sale();
}
```

```java
package bridge;

public class Computer {
    protected Brand brand;

    public Computer(Brand brand) {
        this.brand = brand;
    }

    public void sale() {
        brand.sale();
    }
}


```

```java
package bridge;

public class Desktop extends Computer{

    public Desktop(Brand brand) {
        super(brand);
    }
}
```

```java
package bridge;

public class Laptop extends Computer {
    public Laptop(Brand brand) {
        super(brand);
    }
}
```

```java
package bridge;

public class Lenovo implements Brand {
    @Override
    public void sale() {

    }
}
```

```java
package bridge;

public class Pad extends Computer {
    public Pad(Brand brand) {
        super(brand);
    }
}
```

## 组合模式

Composite Pattern

应用场景

- 把部分和整体的关系用树状结构表示，从而使客户端可以使用统一的方法处理部分对象和整体对象

组合模式核心：

- 抽象构建（Component）角色：定义了叶子和容器构建的共同点
- 叶子（Leaf）构建角色：无子节点（树的叶子节点）
- 容器（Composite）构建角色：有容器特征，可以包含子节点（树的非叶子结点）

```java
package composite;

import java.util.ArrayList;
import java.util.List;

/**
 * 抽象构建
 */
public interface AbstractFile {
    void killVirus();
}

class Folder implements AbstractFile {

    /**
     * 用于存下面的叶子节点
     */
    private List<AbstractFile> list = new ArrayList<>();

    @Override
    public void killVirus() {
        System.out.println("查杀文件夹");
        for(AbstractFile file : list) {
            // 文件夹内还有文件夹或文件夹下还有目录
            file.killVirus();
        }
    }
}

/**
 * 叶子
 */
class ImageFile implements AbstractFile {

    @Override
    public void killVirus() {
        System.out.println("查杀图像文件");
    }
}

/**
 * 叶子
 */
class TextFile implements AbstractFile {

    @Override
    public void killVirus() {
        System.out.println("查杀文本文件");
    }
}

```

## 装饰器模式

Decorator Pattern

职责

- 动态的为一个对象增加新的功能
- 是一种**替代继承**的技术，无需通过继承增加子类就能拓展对象的新功能。适用对象的关联关系替代继承关系，更加灵活，同时**避免类型体系的快速膨胀**。

实现细节

- Component抽象构建角色：真实对象和装饰对象有相同的接口。这样客户端对象就能够以与真实对象相同的方式同装饰对象交互。
- ConcreteComponent具体构建角色（真实角色）：io流中的FileInputStream、FileOutputStream
- Decorator装饰角色：持有一个抽象构件的引用。装饰对象接受所以客户端的请求，并把这些请求转发给真实的对象，这样就能够在真实对象调用前后增加新的功能。
- ConcreteDecorator具体装饰角色：负责给构建对象增加新的责任。

总结：

- 装饰模式也叫包装器模式
- 装饰模式降低系统的耦合度，可以动态的增加或删除对象的职责，并使得装饰的具体构建累和具体装饰类可以独立化，以便增加新的具体构建类和具体装饰类

优点：

- 拓展对象功能，比继承灵活，不会导致类的个数急剧增加
- 可以对一个对象进行多次装饰，创造出不同行为的组合，获得功能更加强大的对象
- 具体构建类和具体装饰类可以独立变化，用户可以根据需要自己增加新的具体构建子类和具体装饰子类

缺点：

- 产生很多小对象。大量小对象占据内存，一定程度上影响性能
- 装饰模式容易出错，调试排查比较麻烦

```java
package decorator;

public interface ICar {
    void move();
}

class Car implements ICar{

    @Override
    public void move() {
        System.out.println("陆地上跑");
    }
}

// Decorator装饰角色
class SuperCar implements ICar {
    private ICar car;

    public SuperCar(ICar car) {
        super();
        this.car = car;
    }

    @Override
    public void move() {
        car.move();
    }
}

// 具体装饰角色
class FlyCar extends SuperCar {

    public FlyCar(ICar car) {
        super(car);
    }

    public void fly() {
        System.out.println("天上飞");
    }

    @Override
    public void move() {
        super.move();
        fly();
    }
}

// 具体装饰角色
class WaterCar extends SuperCar {

    public WaterCar(ICar car) {
        super(car);
    }

    public void swim() {
        System.out.println("水上游");
    }

    @Override
    public void move() {
        super.move();
        swim();
    }
}
```

```java
package decorator;

public class Client {
    public static void main(String[] args) {
        Car car = new Car();
        car.move();

        System.out.println("增加新的功能，飞行-------");
        FlyCar flyCar = new FlyCar(car);
        flyCar.move();

        System.out.println("增加新功能，水上游-------");
        WaterCar waterCar = new WaterCar(flyCar);
        waterCar.move();
    }
}
```

## 外观模式

Facade Pattern

迪米特法则：一个软件实体应当尽可能少的与其他实体发生相互作用

外观模式核心：

- 为子系统提供统一的入口。封装子系统的复杂性，便于客户端调用。

## 享元模式

FlyWeight Pattern

场景：内存属于稀缺资源，如果有很多个完全相同或相似的对象，我么可以通过享元模式，节省内存。

核心：

- 享元模式以共享的方式高效地支持大量细粒度对象的崇勇。
- 享元对象可以做到共享的关键是区分了内部状态和外部状态。
  - 内部状态：可以共享，不会随环境变化而改变
  - 外部状态：不可以共享，会随外部变化而改变。

ex：五子棋，每个棋子的外观（颜色、形状、大小）都一样，只有位置不一样。可以共享外观数据

享元模式实现：

- FlyWeightFactory 享元工厂类：创建并管理享元对象，享元池一般设计成键值对。
- FlyWeight抽象享元类：通常是一个接口或抽象类，申明公共方法，这些方法可以像外部提供对象的内部状态，设置外部状态。
- ConcreteFlyWeight具体享元类：为内部状态提供成员变量进行存储。
- UnsharedConcreteFlyWeight非共享享元类：不能呗共享的子类可以设计为非共享享元类。

优点：

- 极大的减少了内存中对象的数量
- 极大的节约资源，提高系统性能
- 外部状态相对独立，不影响内部状态

缺点：

- 设计模式复杂，使程序逻辑复杂
- 为了节省内存，需要读取外部状态。用时间换空间。

```java
package flyweight;

public class Client {

    public static void main(String[] args) {
        Chess chess1 = ChessFactory.getChess("黑色");
        Chess chess2 = ChessFactory.getChess("黑色");

        // 内部状态
        System.out.println(chess1);
        System.out.println(chess2);

        System.out.println("增加外部状态----------------");
        chess1.display(new Coordinate(10, 20));
        chess2.display(new Coordinate(10, 30));
    }
}
```

```java
package flyweight;

/**
 * 享元类
 */
public interface Chess {
    void setColor(String color);
    String getColor();
    void display(Coordinate coordinate);
}

/**
 * 具体的享元类 concreteFlyWeight
 */
class ConcreteChess implements Chess {

    private String color;

    public ConcreteChess(String color) {
        this.color = color;
    }

    @Override
    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String getColor() {
        return color;
    }

    @Override
    public void display(Coordinate coordinate) {
        System.out.println("颜色：" + color);
        System.out.println("位置：" + coordinate.getX() + coordinate.getY());
    }
}
```

```java
package flyweight;

import java.util.HashMap;
import java.util.Map;

/**
 * 享元工厂，flyWeightFactory
 */
public class ChessFactory {

    // 享元池
    private static Map<String, Chess> map = new HashMap<>();

    public static Chess getChess(String color) {

        if(map.get(color) != null) {
            // 如果在享元池中有该对象直接返回
            return map.get(color);
        } else {
            Chess chess = new ConcreteChess(color);
            map.put(color, chess);
            return chess;
        }
    }
}
```

```java
package flyweight;


/**
 * 外部状态-UnSharedConcreteFlyWeight
 */
public class Coordinate {
    private int x;
    private int y;

    public Coordinate(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }
}
```

# 行为型模式

> 关注系统中对象之间相互交互，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责。

## 责任链模式

Chain of Responsibility

定义：将能够处理同一类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，如果能责处理，如果不能责传递给链上的下一个对象。

> 开发中常见的：Java的异常机制、Servelet的过滤器的链式处理

```java
package chainOfResp;

public class Client {
    public static void main(String[] args) {
        Leader a = new Manager("张三");
        Leader b = new Director("李四");

        // 组织责任链对象关系
        a.setNextLeader(b);


        // 开始请假操作
        LeaveRequest request1 = new LeaveRequest("Tom", 5, "回家");
        a.handleRequest(request1);
    }
}
```

```java
package chainOfResp;

/**
 * 主任
 */
public class Director extends Leader{

    public Director(String name) {
        super(name);
    }

    @Override
    public void handleRequest(LeaveRequest request) {
        if(request.getLeaveDays() < 3) {
            System.out.println("员工：" + request.getEmpName() + "请假");
            System.out.println("主任：" + this.name + "审批");
        } else {
            if(this.nextLeader != null) {
                this.nextLeader.handleRequest(request);
            }
        }
    }
}
```

```java
package chainOfResp;

/**
 * 抽象类
 */
public abstract class Leader {
    protected String name;
    protected Leader nextLeader;

    public Leader(String name) {
        this.name = name;
    }

    // 设定责任链上的后继对象
    public void setNextLeader(Leader nextLeader) {
        this.nextLeader = nextLeader;
    }

    /**
     * 处理请求的核心业务方法
     * @param request
     */
    public abstract void handleRequest(LeaveRequest request);
}
```

```java
package chainOfResp;

/**
 * 封装请加的基本信息
 */
public class LeaveRequest {
    private String empName;
    private int leaveDays;
    private String reason;

    public LeaveRequest(String empName, int leaveDays, String reason) {
        this.empName = empName;
        this.leaveDays = leaveDays;
        this.reason = reason;
    }

    public String getEmpName() {
        return empName;
    }

    public void setEmpName(String empName) {
        this.empName = empName;
    }

    public int getLeaveDays() {
        return leaveDays;
    }

    public void setLeaveDays(int leaveDays) {
        this.leaveDays = leaveDays;
    }

    public String getReason() {
        return reason;
    }

    public void setReason(String reason) {
        this.reason = reason;
    }
}
```

```java
package chainOfResp;

/**
 * 经理
 */
public class Manager extends Leader{

    public Manager(String name) {
        super(name);
    }

    @Override
    public void handleRequest(LeaveRequest request) {
        if(request.getLeaveDays() < 10) {
            System.out.println("员工：" + request.getEmpName() + "请假");
            System.out.println("经理：" + this.name + "审批");
        } else {
            // 其他内容
        }
    }
}
```

## 迭代器模式

Iterator Pattern

> 提供一种可以遍历聚合对象的方法。又称为游标模式Cursor Pattern
>
> 聚合对象：存储数据
>
> 迭代器：遍历数据

Java提供了迭代器

```java
package iterator;

public class Client {

    public static void main(String[] args) {
        ConcreteMyAggregate cma = new ConcreteMyAggregate();
        cma.addObject("aaa");
        cma.addObject("ccc");
        cma.addObject("bbb");

        MyIterator iter = cma.createIterator();
        while (iter.hasNext()) {
            System.out.println(iter.getCurrentObj());
            iter.next();
        }
    }
}
```

```java
package iterator;

import java.util.ArrayList;
import java.util.List;

/**
 * 自定义聚合容器
 */
public class ConcreteMyAggregate {
    private List<Object> list = new ArrayList<Object>();

    public void addObject(Object ele) {
        this.list.add(ele);
    }

    public void removeObject(Object ele) {
        this.list.remove(ele);
    }

    public List<Object> getList() {
        return list;
    }

    public void setList(List<Object> list) {
        this.list = list;
    }

    // 获得迭代器
    public MyIterator createIterator() {
        return new ConcreteIterator();
    }

    // 使用内部类定义迭代器，可以直接使用外部类的属性
    private class ConcreteIterator implements MyIterator {

        private int cursor; // 定义游标，用于记录遍历时的位置

        @Override
        public void first() {
            cursor = 0;
        }

        @Override
        public void next() {
            if(cursor < list.size()) {
                cursor++;
            }
        }

        @Override
        public boolean hasNext() {
            if(cursor < list.size()) {
                return true;
            } else {
                return false;
            }
        }

        @Override
        public boolean isFirst() {
            return cursor == 0;
        }

        @Override
        public boolean isLast() {
            return cursor == (list.size() - 1);
        }

        @Override
        public Object getCurrentObj() {
            return list.get(cursor);
        }
    }

}
```

```java
package iterator;


public interface MyIterator {

    /**
     * 将游标指向第一个
     */
    void first();

    /**
     * 将游标指向下一个
     */
    void next();

    /**
     * 判断游标是否为最后一个
     */
    boolean hasNext();

    boolean isFirst();
    boolean isLast();

    /**
     * 获取当前游标指向的对象
     */
    Object getCurrentObj();
}
```

## 中介者模式

Mediator Pattern

- 如果一个系统中对象之间的联系呈现网状结构，<font color=red>对象之间存在大量的多对多的关系</font>，将导致关系及其复杂，这些对象称为“同事对象”
- 我么可以引入一个<font color=red>中介者对象</font>，使各个同事时间跟中介者对象打交道，将复杂的网络结构化解为星形结构

> MVC模式中，C控制器就是一个中介对象，M和V都和他打交道
>
> GUI开发中，多个类通过一个中介者对象与界面进行交互
>
> Java.lang.reflect.Method#invoke()

```java
package mediator;

public class Client {
    public static void main(String[] args) {

        Mediator m = new President();

        Department f = new Financial(m);
        Department d = new Development(m);

        f.selfAction();
        f.outAction();

        System.out.println();
        d.selfAction();
        d.outAction();
    }
}
```

```java
package mediator;


/**
 * 同事类接口
 */
public interface Department {

    void selfAction(); //做本部门的事情
    void outAction(); //向总经理（中介）发出申请
}
```

```java
package mediator;

/**
 * 研发部门
 */
public class Development implements Department{

    private Mediator mediator; //持有中介者

    public Development(Mediator mediator) {
        super();
        this.mediator = mediator;
        mediator.register("development部门", this); // 注册中介
    }

    @Override
    public void selfAction() {
        System.out.println("研究研发项目");
    }

    @Override
    public void outAction() {
        System.out.println("申请资金支持");
        mediator.command("Financial部门");

    }
}
```

```java
package mediator;

public class Financial implements Department {

    private Mediator mediator;

    public Financial(Mediator mediator) {
        super();
        this.mediator = mediator;
        mediator.register("Financial部门", this);
    }

    @Override
    public void selfAction() {
        System.out.println("审批资金");
    }

    @Override
    public void outAction() {
        // 调用中介者
        mediator.command("development部门");
    }
}
```

```java
package mediator;

/**
 * 中介接口
 */
public interface Mediator {

    void register(String dName, Department p);

    void command(String dName);
}
```

```java
package mediator;

import java.util.HashMap;
import java.util.Map;

public class President implements Mediator {

    private Map<String ,Department> map= new HashMap<String, Department>();

    @Override
    public void register(String dName, Department p) {
        map.put(dName, p);
    }

    /**
     * @param dName 需要调用部门的名字
     */
    @Override
    public void command(String dName) {
        // 其它部门可以调用该方法，来让中介者调用其它部门
        map.get(dName).selfAction();
    }
}
```

## 命令模式

Command Pattern

命令模式：讲一个请求封装成一个对象，从而使我们可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。也称之为：动作Action模式、事物transaction模式

结构：

- Command抽象命令类
- ConcreteCommand具体命令类
- Invoker调用者/请求者
  - 请求的发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接受不了者，因此它只与抽象命令类之间存在关联。在程序运行时，将调用命令对象的execute()，间接调用接收者的相关操作。
- Receiver接收者
  - 接收者执行与请求相关的操作，具体实现对请求的事物处理
  - 未抽象前，实际执行操作内容的对象
- Client客户类
  - 在客户类中需要创建调用者对象、具体命令类，在创建具体命令对象时指定对应的接收者。发送者和接收者之间没有直接关系，都是通过命令对象简介调用。

开发中常见场景：

- Struts2中，action的整个调用过程
- 数据库事务机制的底层实现
- 命令的撤销和恢复

## 解释器模式

Interpreter Pattern

- 不常用的设计模式
- 用于描述如何构成一个简单的语言解释器，主要用于使用面向对象语言开发的编译器和解释器设计
- 当需要开发一种新语言时，可以考虑解释器模式
- 尽量不要使用，维护麻烦。在项目中可以使用Jruby、Groovy、Java的Js引擎来替代解释器的作用，弥补Java语言的不足。

开发常见的场景

- EL表达式的处理
- 正则表达式的处理
- SQL语言法解释器
- 数学表达式的解释器

```java
package interpreter;

public class Client {
    public static void main(String[] args) {
        PlayContext playContext = new PlayContext();
        System.out.println("上海滩");
        playContext.setText("O 2 E 0.5 G 0.5 A 3 E 0.5 G 0.5 D 3 E 0.5 G 0.5 A 0.5 O 3 C 1 O 2 A 0.5 G 1 C 0.5 E 0.5 D 3 ");
        Expression expression = null;
        while (playContext.getText().length() > 0) {
            String str = playContext.getText().substring(0, 1);
            switch (str) {
                case "O":
                    expression = new Scale();
                    break;
                case "C":
                case "D":
                case "E":
                case "F":
                case "G":
                case "A":
                case "B":
                case "P":
                    expression = new Note();
                    break;
            }
            expression.interpret(playContext);
        }
    }

}
```

```java
package interpreter;

public abstract class Expression {

    public void interpret(PlayContext context) {
        if (context.getText().length() <= 0) {
            return;
        } else {
            // 当前演奏文本的第一条命令字母和参数值
            // 例如 O 3 G 0.5 A 0.5 E 3
            // 则 playKey 为 O, playValue 为 3
            String playKey = context.getText().substring(0, 1);
            context.setText(context.getText().substring(2));
            double playValue = Double.valueOf(context.getText().substring(0, context.getText().indexOf(" ")));
            execute(playKey, playValue);
            context.setText(context.getText().substring(context.getText().indexOf(" ") + 1));
        }
    }

    // 执行
    public abstract void execute(String key, double value);
}
```

```java
package interpreter;

public class Note extends Expression {
    @Override
    public void execute(String key, double value) {
        String note = "";
        // 如果是C 则演奏 1,
        // 如果是 D 则演奏 2, 一次类推...
        switch (key) {
            case "C":
                note = "1";
                break;
            case "D":
                note = "2";
                break;
            case "E":
                note = "3";
                break;
            case "F":
                note = "4";
                break;
            case "G":
                note = "5";
                break;
            case "A":
                note = "6";
                break;
            case "B":
                note = "7";
                break;
        }
        System.out.print(note + " ");
    }
}
```

```java
package interpreter;

// 演奏内容类
public class PlayContext {
    // 演奏文本
    private String text;
    public String getText() {
        return text;
    }
    public void setText(String text) {
        this.text = text;
    }
}
```

```java
package interpreter;

public class Scale extends Expression {
    @Override
    public void execute(String key, double value) {
        // 如果获得的 key 为O, value 为1 则演奏低音
        String note = "";
        switch ((int)value) {
            case 1:
                note = "低音";
                break;
            case 2:
                note = "中音";
                break;
            case 3:
                note = "高音";
                break;
        }
        System.out.print(note + " ");
    }
}
```

## 访问者模式

Virsitor Pattern

模式动机：对于存储在一个集合中的对象，他们可能具有不同的类型（即使有一个公共的接口），对于该集合中的对象，可以接收一类称为访问者的对象来访问，不同的访问者其访问的方式也不同

定义：表示一个作用于某个对象结构中的各元素的操作，它们使我们可以在不改变单个元素类的前提下定义作用于这些元素的新操作

开发常见

- XML文档解析器设计
- 编译器的设计
- 复杂集合对象的处理

## 策略模式

Strategy Pattern

与简单工厂模式相似

策略模式对应于解决某一问题的一个算法族，允许用户从该算法族中任选一个算法解决某一个问题，同时可以方便的更换算法或者增加新的算法。并由客户端决定调用哪个算法

本质：分离算法，选择实现

开发中常见的场景：

- JavaSE中GUI编程中，布局管理
- Spring框架中，Resource接口，资源访问策略
- javax.servlet.http.HttpServlet#service()

## 模版方法模式

Template Method Pattern

介绍：模版方法模式时编程中经常用到的模式。它**定义了一个操作中的算法骨架**，将某些步骤延迟到子类中实现。这样心的子类可以在不改变算法结构的前提下重新定义该算法的某些特定步骤。

核心：处理某个流程的代码已经都具备，但是其中某个节点的代码暂时不能确定。因此，温我们采用工厂方法模式，将这个节点的代码转移给子类完成。即：<font color=red>处理步骤在父类中定义，具体实现延迟到子类中定义</font>

使用：实现一个算法是，整个步骤很固定，但是某些部分易变。易变的部分可以抽象出来，供子类实现。

开发中常见的场景：非常频繁的被使用

- 数据库访问的封装
- Junit单元测试
- servlet中关于doGet/doPost方法的调用
- Hibernate中模版程序
- spring中JDBCTemplate、HibernateTemplate等

```java
package templateMethod;

/**
 * @author uio
 * Date 2021/2/24 02:20
 * Description: 模版方法
 */
public abstract class BankTemplateMethod {

    public void takeNumber() {
        System.out.println("排队取号");
    }

    public abstract void transact(); //办理具体的业务

    public void evaluate() {
        System.out.println("反馈评分");
    }

    // 模版方法，把基本的操作组合到一起，子类一般不能重写
    public final void process() {
        this.takeNumber();
        this.transact(); //像一个钩子，执行时挂哪个子类的方法就调用哪个子类
        this.evaluate();
    }
}
```

## 状态模式

State Pattern

场景：不同的状态对应不同的行为

核心：用于解决系统中复杂对象的状态转换以及不同状态下的行为的封装

结构：

- Context环境类：环境类中维护一个State对象，它是定义了当前的状态
- State抽象对象
- ConcreateState具体状态类：每一个类状态了一个状态对应的行为

```java
package state;

/**
 * @author uio
 * Date 2021/2/24 02:47
 * Description: 维持不同状态之间的切换
 */
public class Context {
    private State state;

    public void setState(State state) {
        this.state = state;
        state.handle();
    }
}
```

```java
package state;

/**
 * @author uio
 * Date 2021/2/24 02:46
 * Description: 已预定状态
 */
public class BookedState implements State{
    @Override
    public void handle() {
        System.out.println("已预定");
    }
}
```

```java
package state;

/**
 * @author uio
 * Date 2021/2/24 02:47
 * Description: 已入住
 */
public class CheckedInState implements State{
    @Override
    public void handle() {
        System.out.println("已入住");
    }
}
```

```java
package state;

/**
 * @author uio
 * Date 2021/2/24 02:44
 * Description: 空闲状态
 */
public class FreeState implements State{

    @Override
    public void handle() {
        System.out.println("房间空闲");
    }
}
```

```java
package state;

/**
 * @author uio
 * Date 2021/2/24 02:45
 * Description: 抽象状态类
 */
public interface State {
    void handle();
}
```

## 观察者模式

Observer Pattern

核心

- 观察者模式主要用于1:N的通知。当一个对象（目标对象Subject或Objservable）的状态变化时（**消息发布**），它需要及时告知一系列对象（观察者，Observer），令它们作出响应（**消息订阅**）
- 通知观察者的方法
  1. 推：每次都会把通知以广播的方式发送给所有观察者，所有观察者只能被动接收
  2. 拉：观察者只要知道有情况即可。至于什么时候获得内容，获取什么内容，都可以自主决定

**JavaSE提供了java.util.Observable和java.util.Observer来实现观察者模式**

开发常见的场景：

- 聊天室程序，服务器转发给所有客户端
- 网络游戏多人联机对战
- 邮件订阅
- Servlet中监听器的实现
- 群发某商品的打折信息

#### 全手写实现观察者

```java
package observer;

/**
 * @author uio
 * Date 2021/2/24 20:27
 * Description: 客户端
 */
public class Client {
    public static void main(String[] args) {

        // 目标对象
        ConcreteSubject subject = new ConcreteSubject();

        // 创建多个观察者
        ObserverA obs1 = new ObserverA();
        ObserverA obs2 = new ObserverA();
        ObserverA obs3 = new ObserverA();

        // 让这三个观察者添加到subject对象的观察者队伍中
        subject.register(obs1);
        subject.register(obs2);
        subject.register(obs3);

        // 改变subject的状态
        subject.setState(300);

        // 看看观察者的状态是否改变
        System.out.println("obs1:" + obs1.getMyState());
        System.out.println("obs2:" + obs2.getMyState());
        System.out.println("obs3:" + obs3.getMyState());
    }
}
```

```java
package observer;

/**
 * @author uio
 * Date 2021/2/24 20:34
 * Description:
 */
public class ConcreteSubject extends Subject {

    private int state;

    public int getState() {
        return state;
    }

    public void setState(int state) {
        this.state = state;
        this.notifyAllObservers(); //状态发生变化，通知所以的观察者
    }
}
```

```java
package observer;

/**
 * @author uio
 * Date 2021/2/24 20:31
 * Description: 观察者接口
 */
public interface Observer {
    void update(Subject subject);
}
```

```java
package observer;

/**
 * @author uio
 * Date 2021/2/24 20:36
 * Description:
 */
public class ObserverA implements Observer{

    private int myState; //myState需要跟目标对象的state保持一直

    @Override
    public void update(Subject subject) {
        myState = ((ConcreteSubject)subject).getState();
    }

    public int getMyState() {
        return myState;
    }

    public void setMyState(int myState) {
        this.myState = myState;
    }
}
```

```java
package observer;

import java.util.ArrayList;
import java.util.List;

/**
 * @author uio
 * Date 2021/2/24 20:32
 * Description:
 */
public class Subject {

    protected List<Observer> list = new ArrayList<>();

    public void register(Observer observer) {
        list.add(observer);
    }

    public void removeObserver(Observer observer) {
        list.remove(observer);
    }

    /*
    通知所有观察者更新状态
     */
    public void notifyAllObservers() {
        for(Observer observer : list) {
            observer.update(this);
        }
    }
}
```

#### Java提供观察者

```java
package observer.javaProvide;

/**
 * @author uio
 * Date 2021/2/24 20:47
 * Description:
 */
public class Client {
    public static void main(String[] args) {

        // 创建目标对象
        ConcreteSubject concreteSubject = new ConcreteSubject();

        // 创建观察者
        ObserverA obs1 = new ObserverA();
        ObserverA obs2 = new ObserverA();
        ObserverA obs3 = new ObserverA();

        concreteSubject.addObserver(obs1);
        concreteSubject.addObserver(obs2);
        concreteSubject.addObserver(obs3);

        concreteSubject.set(300);

        System.out.println(obs1.getMyState());
        System.out.println(obs2.getMyState());
        System.out.println(obs3.getMyState());
    }
}
```

```java
package observer.javaProvide;

import java.util.Observable;
import java.util.Observer;

/**
 * @author uio
 * Date 2021/2/24 20:43
 * Description: 目标对象
 */
public class ConcreteSubject extends Observable {

    private int state;

    public void set(int state) {
        this.state = state; //变更目标对象的状态

        setChanged(); //表示目标对象以及发生了变更
        notifyObservers(state); //调用父类的方法，通知所有的观察者
    }

    public int getState() {
        return state;
    }

    public void setState(int state) {
        this.state = state;
    }
}
```

```java
package observer.javaProvide;

import java.util.Observable;
import java.util.Observer;

/**
 * @author uio
 * Date 2021/2/24 20:45
 * Description: 观察者
 */
public class ObserverA implements Observer {

    private int myState;

    @Override
    public void update(Observable o, Object arg) {
        myState = ((ConcreteSubject)o).getState();
    }

    public int getMyState() {
        return myState;
    }

    public void setMyState(int myState) {
        this.myState = myState;
    }
}
```

## 备忘录模式

Memento Pattern

核心：保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复到原先的状态

结构：

- 源发器类Originator
- 备忘录类Memento
- 负责人类CareTake

备忘点较多时：

- 将备忘录压栈
- 将备忘录对象进行序列化和持久化

```java
package memento;


/**
 * @author uio
 * Date 2021/2/24 21:04
 * Description:
 */
public class Client {

    public static void main(String[] args) {
        CareTake careTake = new CareTake();

        Emp emp = new Emp("小明", "18", 900.0);
        System.out.println("第一次打印对象" + emp.toString());

        careTake.setMemento(emp.memento()); //备份操作

        emp.setAge("38");
        emp.seteName("小红");

        System.out.println("第二次打印对象" + emp.toString());

        emp.recovery(careTake.getMemento()); //恢复备忘录管理对象管理的备忘录的值
        System.out.println("第三次打印对象" + emp.toString());

    }
}
```

```java
package memento;

/**
 * @author uio
 * Date 2021/2/24 21:03
 * Description: 负责人类，负责管理备忘录对象
 */
public class CareTake {
    private EmpMemento memento;	//可以改成其它容器，管理很多个备忘点

    public EmpMemento getMemento() {
        return memento;
    }

    public void setMemento(EmpMemento memento) {
        this.memento = memento;
    }
}
```

```java
package memento;

/**
 * @author uio
 * Date 2021/2/24 20:58
 * Description: 源发器类
 */
public class Emp {
    private String eName;
    private String age;
    private double salary;

    // 进行备忘操作，并返回备忘录对象
    public EmpMemento memento() {
        return new EmpMemento(this);
    }

    // 进行数据恢复，恢复成指定备忘录对象的值
    public void recovery(EmpMemento empMemento) {
        this.eName = empMemento.geteName();
        this.age = empMemento.getAge();
        this.salary = empMemento.getSalary();
    }

    @Override
    public String toString() {
        return "Emp{" +
                "eName='" + eName + '\'' +
                ", age='" + age + '\'' +
                ", salary=" + salary +
                '}';
    }

    public Emp(String eName, String age, double salary) {
        this.eName = eName;
        this.age = age;
        this.salary = salary;
    }

    public String getAge() {
        return age;
    }

    public void setAge(String age) {
        this.age = age;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }

    public String geteName() {
        return eName;
    }

    public void seteName(String eName) {
        this.eName = eName;
    }
}
```

```java
package memento;

/**
 * @author uio
 * Date 2021/2/24 21:00
 * Description: 备忘录类
 */
public class EmpMemento {
    private String eName;
    private String age;
    private double salary;

    public EmpMemento(Emp emp) {
        this.eName = emp.geteName();
        this.age = emp.getAge();
        this.salary = emp.getSalary();
    }

    public String geteName() {
        return eName;
    }

    public void seteName(String eName) {
        this.eName = eName;
    }

    public String getAge() {
        return age;
    }

    public void setAge(String age) {
        this.age = age;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }
}
```









